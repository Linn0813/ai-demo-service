"""LLM提示词构建工具"""
from __future__ import annotations

from typing import Any, Dict, List, Optional

from models.schemas import DocumentUnderstanding


def build_generation_prompt(requirement_doc: str) -> str:
    """构建测试用例生成的提示词。"""

    return f"""你是一位有着10年测试经验的资深测试工程师，精通ISTQB测试标准和移动端测试最佳实践。请仔细阅读以下需求文档，并严格按照文档内容生成全面的测试用例。

【任务要求】
根据以下需求文档，生成全面的测试用例。必须严格按照需求文档中的实际功能点生成，确保功能覆盖率≥85%。

【需求文档】
{requirement_doc}

【生成要求 - 功能覆盖率】
必须为每个功能模块生成足够全面的测试用例，确保覆盖以下维度：

1. **UI元素测试（必须覆盖）**
   - 所有按钮（点击、显示、状态）
   - 所有字段（输入、显示、格式）
   - 所有标题、文案、提示信息
   - 所有图表、图片、图标
   - 所有弹窗、卡片、列表项
   - 确保每个UI元素都有至少1个测试用例

2. **业务规则测试（必须覆盖）**
   - 所有判断条件（如果...则...）
   - 所有计算规则（数值计算、时间计算）
   - 所有显示规则（何时显示、何时隐藏）
   - 所有状态转换（有效→无效、有数据→无数据）
   - 确保每个业务规则都有至少1个测试用例

3. **边界条件测试（必须覆盖）**
   - 数值边界：最少、最多、临界值
   - 时间边界：边界时间点、时间范围
   - 数据量边界：数据不足、数据充足、临界数据量
   - 字符边界：最小长度、最大长度、特殊字符
   - 确保每个边界条件都有至少1个测试用例

4. **交互逻辑测试（必须覆盖）**
   - 所有用户操作（点击、输入、选择、滑动）
   - 所有流程跳转（页面跳转、弹窗打开/关闭）
   - 所有状态变化（按钮启用/禁用、显示/隐藏）
   - 所有数据联动（日期切换、选项联动）
   - 确保每个交互逻辑都有至少1个测试用例

5. **移动端专项测试（建议覆盖）**
   - 兼容性测试：不同设备、系统版本、屏幕尺寸
   - 可用性测试：操作流程易用性、界面布局合理性
   - 网络环境：WiFi、4G、5G、弱网、无网
   - 横竖屏切换：界面适配、功能可用性

【测试设计方法应用】
在生成测试用例时，必须应用以下测试设计方法：

1. **等价类划分**
   - 有效等价类：存在有效数据、满足条件的数据
   - 无效等价类：无有效数据、不满足条件的数据
   - 为每个等价类生成至少1个测试用例

2. **边界值分析**
   - 必须测试所有边界值：最少、最多、临界值
   - 必须测试边界值两侧：边界值-1、边界值、边界值+1
   - 为每个边界值生成至少1个测试用例

3. **场景法**
   - 正常场景：完整操作流程
   - 异常场景：错误操作、异常数据
   - 为每个场景生成完整的测试用例（包含前置条件、步骤、预期结果）

4. **决策表**
   - 多条件组合：多个条件的组合情况
   - 为每个条件组合生成测试用例

【预期结果要求 - 严格规定】
**⚠️ 这是最重要的要求，必须严格遵守：**

1. **必须从需求文档中逐字提取预期结果**
   - expected_result字段必须逐字复制需求文档中的原句
   - 不能改写、总结、意译或概括
   - 不能使用通用预期结果（如"点击关闭直接消失"、"正确显示"、"正常显示"等）

2. **预期结果提取方法**
   - **步骤1**：仔细阅读需求文档中关于该功能点的所有描述
   - **步骤2**：查找包含该功能点关键词的句子（如按钮名称、字段名称、操作描述等）
   - **步骤3**：找到描述该功能预期行为或结果的完整句子
   - **步骤4**：逐字复制该句子作为expected_result，不要修改任何文字

3. **预期结果必须具体、可验证**
   - 如果需求文档中有明确的预期结果描述，必须逐字复制
   - 如果需求文档中写"点击X按钮后Y发生"，expected_result必须写"点击X按钮后Y发生"（不能改写成"点击X按钮后Y正确发生"）
   - 如果需求文档中写"显示为A值"，expected_result必须写"显示为A值"（不能改写成"A值正确显示"）

4. **预期结果必须包含需求文档中的关键词**
   - 按钮名称、字段名称、标题文字必须与需求文档一致
   - 数值、时间、状态描述必须与需求文档一致
   - 操作描述、流程步骤必须与需求文档一致

5. **禁止使用通用预期结果**
   - 禁止使用"点击关闭直接消失"等通用描述
   - 禁止使用"正确显示"、"正常显示"、"验证通过"等模糊描述
   - 禁止使用"符合预期"、"满足要求"等抽象描述
   - 必须使用需求文档中的具体描述

6. **找不到原文时的处理**
   - 如果需求文档中没有明确的预期结果描述，尝试查找相关的功能描述、规则说明、状态定义等
   - 如果仍然找不到，可以基于功能点的描述进行合理推断，但必须标注为推断结果
   - 优先查找包含功能点名称、操作动词、状态描述的句子

【其他要求】
1. **所有输出必须使用简体中文，不得出现繁体字或「」等繁体标点**
2. **禁止臆造需求文档中未出现的功能、文案或页面位置**
3. **所有测试步骤必须是App端可执行的实际操作，禁止出现"登录后台""查看数据库""手动投放"等后台或运营动作**
4. **每个测试用例的 steps 至少包含3条明确操作步骤，且每一步都要描述具体交互**
5. **避免写入无法执行的描述（例如"等待7天"），遇到时改写为可执行的验证步骤或拆分为前置条件**
6. **必须生成足够多的测试用例，确保功能覆盖率≥85%**

【输出格式要求】
**重要：只输出JSON格式，不要包含任何其他文字说明！**

每个测试用例必须包含以下字段（按顺序）：
- module_name: 所属模块（功能模块名称，必须与需求文档中的模块名称一致）
- sub_module: 子功能点名称（可选，如果用例属于某个子功能点，填写子功能点名称；如果没有子功能点，可以为空字符串""或null）
- case_name: 用例名称（必须与需求文档中的功能点对应）
- preconditions: 前置条件（基于需求文档中的前置要求，如果没有前置条件，可以为空字符串""）
- steps: 测试步骤（数组格式，每个步骤一行，必须与需求文档中的操作流程一致）
- expected_result: 预期结果（**必须逐字复制需求文档中的原句，不能改写**）

【输出格式示例】
{{
  "test_cases": [
    {{
      "module_name": "模块名称",
      "sub_module": "子功能点名称（可选）",
      "case_name": "用例名称",
      "preconditions": "前置条件（可为空）",
      "steps": ["步骤1：具体操作", "步骤2：具体操作", "步骤3：验证结果"],
      "expected_result": "预期结果（必须逐字复制需求文档中的原句）"
    }}
  ]
}}

**重要说明：**
- module_name 必须填写为功能模块名称
- sub_module 是可选的，只有当用例明确属于某个子功能点时才填写
- 如果功能模块没有子功能点，sub_module 可以为空字符串或null
- **expected_result 必须逐字复制需求文档中的原句，不能改写、总结或意译**

【重要提醒】
1. 只生成需求文档中明确提到的功能
2. 必须生成足够多的测试用例，确保功能覆盖率≥85%
3. **只输出JSON，不要包含任何其他文字说明**
4. **确保JSON格式正确，可以直接解析**
5. **预期结果必须从需求文档中逐字提取，禁止使用通用预期结果**"""


def build_module_extraction_prompt(requirement_doc: str) -> str:
    """构建功能模块提取的提示词。"""

    return f"""你是一个JSON输出工具。你的任务是从需求文档中提取功能模块，并以JSON格式输出结果。

**任务要求：**
1. 仔细阅读以下需求文档
2. 识别并提取所有功能模块
3. **只输出JSON，不要输出任何其他内容**

**⚠️ 严格规则：**
- **严禁臆造模块**：只能提取需求文档中明确提到的模块名称，绝对不能自行创造、概括或推断模块名称
- **必须验证**：提取的每个模块名称，都必须在需求文档中找到对应的明确文字提及
- 如果文档中没有明确提到某个模块，就不要提取该模块
- **禁止输出代码、解释、说明或任何非JSON内容**
- **你的响应必须是一个JSON对象，从 {{ 开始，到 }} 结束，中间不要有任何其他文字**

需求文档：
{requirement_doc}

**功能模块定义：**
功能模块是指需求文档中相对独立、完整的功能单元，通常包含：
- 一个主要功能或业务流程
- 相关的UI组件、交互逻辑、业务规则
- 相关的数据操作、状态管理

**提取要求：**
1. 识别文档中的**所有**主要功能模块，每个模块应该是一个相对完整的页面、弹窗或业务流程
2. **禁止使用泛化的模块名称**（如"主要功能模块"、"核心模块"、"通用模块"等），必须使用文档中明确提到的具体模块名称
3. 如果文档中明确提到了多个独立的模块（即使它们有相似的命名模式），也必须作为独立的模块分别提取，不要合并
4. 仔细扫描文档，找出所有明确命名的模块（如果文档中提到了多个具有相似命名模式的模块，每个都应该作为独立模块提取，不要合并）
5. **禁止拆分模块内部的题目、字段或选项**，例如如果文档中提到"XX测量结果"和"XX测量操作流程"都属于"XX模块"，不要单独输出
6. **禁止将状态、条件、场景识别为独立模块**，例如"存在有效数据"、"无有效数据"等都是状态或条件，应该归属于"状态判断条件"或"判断条件"等模块，不要单独提取
7. **重要：独立的功能单元应该作为独立模块提取**
   - 如果文档中有独立的章节标题（如"详情信息半弹窗"、"设置页面"等），即使它们属于某个更大的功能模块，也应该作为独立的模块提取
   - 只有当某个功能明确是另一个模块的子功能（如"提交按钮"、"确认弹窗"等）时，才应该归入主模块
   - 如果文档中某个功能有独立的章节标题和详细描述，应该作为独立模块提取
   - **特殊情况**：如果文档非常简单，只有一个主要功能且没有独立的子章节标题，则只提取这一个模块即可
8. 每个模块应该包含足够的内容，能够独立进行测试用例生成
9. **重要**：仔细检查文档的每个章节，确保提取了文档中明确提到的所有具体功能模块，不要遗漏，也不要使用泛化的名称
   - 如果文档只有一个模块，就只提取一个模块
   - 如果文档有多个模块，就提取所有模块
10. **特别注意**：优先提取文档中的章节标题，这些通常是主要功能模块，应该作为独立模块提取

**重要要求：**
- **严格禁止臆造模块**：所有模块名称必须直接来自需求文档中明确提到的名称，不能自行创造或概括
- **模块名称必须来自文档**：如果文档中没有明确提到某个模块名称，就不要提取该模块
- 使用简体中文描述模块名称，不要使用繁体字或「」等繁体标点
- 模块名称应该清晰、简洁，能够概括模块的主要功能
- 不要遗漏需求文档中的主要功能模块
- 每个模块必须提供定位线索，帮助程序找到相关原文
- **验证要求**：提取的每个模块名称，都必须在需求文档中能够找到对应的明确提及

**关键词提取要求：**
- keywords：提供2-4个核心关键词，这些关键词必须是文档中真实存在的短语，用于精确定位原文
- 避免过于泛化的词语，优先选择具体的描述性词语
- exact_phrases：提供1-2个文档中的确切短语或句子，这些短语必须逐字来自文档原文，如果找不到原文中的原句，就不要提供
- section_hint：简短的章节名称或上下文线索（可选）

**质量校验：**
- 请优先提取文档章节或标题中的模块，确保这些模块全部出现
- 如果一个名称在文档中多次出现，只输出一次模块
- 每个模块的 `exact_phrases` 和 `keywords` 必须源自原文对应段落，用于帮助定位原文

**重要格式要求：**
- 必须使用双引号，不要使用单引号
- 字符串中的特殊字符要正确转义
- 确保JSON格式完全正确

**模块层次关系识别：**
- 如果模块是文档中的主要功能模块（通常是独立的章节标题），设置 `is_main_module` 为 `true`
- 如果模块是某个主模块的子功能（如"详情信息半弹窗"、"设置页面"等），设置 `is_main_module` 为 `false`，并在 `parent_module` 中指定父模块名称
- 如果无法确定层次关系，可以设置 `is_main_module` 为 `null`，让系统自动判断

**输出格式要求：**
{{
  "function_modules": [
    {{
      "name": "模块名称（必须来自文档）",
      "description": "模块描述",
      "keywords": ["关键词1", "关键词2"],
      "section_hint": "章节提示",
      "exact_phrases": ["文档中的确切短语"],
      "is_main_module": true/false/null,
      "parent_module": "父模块名称（如果是子模块）" 或 null
    }}
  ]
}}

**⚠️ 严格输出要求（必须遵守）：**
1. **只输出JSON格式，绝对不要包含任何解释、说明、代码示例或其他文字**
2. **不要输出"你的问题涉及到..."、"我将尝试..."、"以下是一个示例"等任何解释性文字**
3. **不要输出任何代码块、代码示例或编程指导**
4. **直接输出JSON对象，从 {{ 开始，到 }} 结束，中间只有JSON内容**
5. **如果无法提取模块，输出：{{ "function_modules": [] }}**
6. **禁止输出任何非JSON内容，包括markdown代码块标记、解释文字、代码示例等**

**现在开始输出JSON（只输出JSON，不要其他内容）：**"""


def build_function_point_extraction_prompt(module_name: str, module_content: str) -> str:
    """构建功能点提取的提示词（用于在模块内识别子功能点）。"""

    return f"""你是一个JSON输出工具。你的任务是从功能模块的需求文档中提取子功能点，并以JSON格式输出结果。

**任务要求：**
1. 仔细阅读以下功能模块的需求文档
2. 识别并提取该模块内的所有子功能点
3. **只输出JSON，不要输出任何其他内容**

**功能模块：**
{module_name}

**模块需求文档：**
{module_content}

**功能点定义：**
功能点是指模块内的具体功能、操作、状态或规则，例如：
- 具体的按钮、字段、UI元素
- 具体的交互逻辑、流程步骤
- 具体的业务规则、判断条件
- 具体的状态、场景、异常情况

**提取要求：**
1. 仔细分析模块需求文档，识别所有子功能点
2. **禁止使用泛化的功能点名称**（如"主要功能"、"核心功能"、"通用功能"等），必须使用文档中明确提到的具体功能点名称
3. 每个功能点应该是一个相对独立、可测试的功能单元
4. 如果模块内容简单（少于3个明确的功能点），可以只提取1-2个主要功能点
5. **严格禁止臆造功能点**：所有功能点名称必须直接来自需求文档中明确提到的内容
6. 使用简体中文描述功能点名称，不要使用繁体字或「」等繁体标点

**关键词提取要求：**
- keywords：提供2-3个核心关键词，这些关键词必须是文档中真实存在的短语
- exact_phrases：提供1个文档中的确切短语或句子，用于定位原文

**输出格式要求：**
{{
  "function_points": [
    {{
      "name": "功能点名称（必须来自文档）",
      "description": "功能点描述",
      "keywords": ["关键词1", "关键词2"],
      "exact_phrases": ["文档中的确切短语"]
    }}
  ]
}}

**⚠️ 严格输出要求（必须遵守）：**
1. **只输出JSON格式，绝对不要包含任何解释、说明或其他文字**
2. **直接输出JSON对象，从 {{ 开始，到 }} 结束，中间只有JSON内容**
3. **如果无法提取功能点，输出：{{ "function_points": [] }}**
4. **禁止输出任何非JSON内容**

**现在开始输出JSON（只输出JSON，不要其他内容）：**"""


def build_document_understanding_prompt(requirement_doc: str) -> str:
    """构建文档理解的提示词"""
    return f"""你是一位需求分析专家。请仔细阅读以下需求文档，并理解其整体结构和业务意图。

**任务要求：**
1. 识别文档类型（PRD、需求文档、设计文档、用户故事等）
2. 提取文档的核心主题和业务目标
3. 识别文档的结构（章节、层级、标题）
4. 提取关键业务概念和术语
5. 分析文档的完整性和清晰度
6. 评估文档的复杂度

**需求文档：**
{requirement_doc}

**输出格式：**
{{
  "document_type": "文档类型",
  "main_topic": "核心主题",
  "business_goals": ["业务目标1", "业务目标2"],
  "key_concepts": ["概念1", "概念2"],
  "key_terms": ["术语1", "术语2"],
  "business_rules": ["规则1", "规则2"],
  "completeness": "完整/不完整",
  "clarity": "清晰/模糊",
  "quality_score": 0.0-1.0,
  "estimated_complexity": "简单/中等/复杂"
}}

**⚠️ 只输出JSON，不要包含任何其他内容**"""


def build_module_extraction_prompt_with_understanding(
    requirement_doc: str,
    understanding: DocumentUnderstanding
) -> str:
    """基于理解结果构建功能模块提取提示词"""
    # 构建理解结果摘要
    understanding_summary = f"""
**文档理解结果（用于辅助提取）：**
- 文档类型：{understanding.document_type}
- 核心主题：{understanding.main_topic}
- 业务目标：{', '.join(understanding.business_goals[:5]) if understanding.business_goals else '无'}
- 关键概念：{', '.join(understanding.key_concepts[:5]) if understanding.key_concepts else '无'}
- 文档结构：{understanding.structure.section_count}个章节，层级：{understanding.structure.hierarchy_levels}
- 主要章节：{', '.join(understanding.structure.main_sections[:5]) if understanding.structure.main_sections else '无'}
"""

    # 在原有提示词基础上增加理解结果信息
    base_prompt = build_module_extraction_prompt(requirement_doc)
    
    # 在需求文档之前插入理解结果摘要
    doc_marker = "需求文档："
    if doc_marker in base_prompt:
        parts = base_prompt.split(doc_marker, 1)
        return parts[0] + understanding_summary + "\n" + doc_marker + parts[1]
    
    # 如果找不到标记，直接追加
    return base_prompt.replace(
        "需求文档：",
        understanding_summary + "\n需求文档：",
        1
    )


def build_generation_prompt_with_understanding(
    requirement_doc: str,
    understanding: DocumentUnderstanding,
    confirmed_function_points: Optional[List[Dict[str, Any]]] = None
) -> str:
    """基于理解结果构建测试用例生成提示词"""
    # 构建理解结果摘要
    understanding_summary = f"""
**文档理解结果（用于辅助生成）：**
- 文档类型：{understanding.document_type}
- 核心主题：{understanding.main_topic}
- 业务目标：{', '.join(understanding.business_goals[:5]) if understanding.business_goals else '无'}
- 关键概念：{', '.join(understanding.key_concepts[:5]) if understanding.key_concepts else '无'}
- 业务规则：{', '.join(understanding.business_rules[:3]) if understanding.business_rules else '无'}
- 文档复杂度：{understanding.estimated_complexity}
"""

    # 在原有提示词基础上增加理解结果信息
    base_prompt = build_generation_prompt(requirement_doc)
    
    # 在需求文档之前插入理解结果摘要
    doc_marker = "【需求文档】"
    if doc_marker in base_prompt:
        parts = base_prompt.split(doc_marker, 1)
        return parts[0] + understanding_summary + "\n" + doc_marker + parts[1]
    
    # 如果找不到标记，直接追加
    return base_prompt.replace(
        "【需求文档】",
        understanding_summary + "\n【需求文档】",
        1
    )
